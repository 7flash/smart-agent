// smart-agent/src/index.test.ts
import { test, expect, describe, mock } from "bun:test"
import { Agent } from "./agent"
import { objToXml, xmlToObj } from "./xml"
import { loadSkills, formatSkillsForPrompt } from "./skills"
import { createBuiltinTools } from "./tools"
import { writeFileSync, mkdirSync, rmSync } from "fs"
import { join } from "path"

// ── XML Tests ──

describe("XML", () => {
    test("round-trip simple object", () => {
        const obj = { name: "Alice", age: 30 }
        const xml = objToXml(obj)
        expect(xml).toContain("<name>Alice</name>")
        expect(xml).toContain("<age>30</age>")
        const parsed = xmlToObj(xml)
        expect(parsed.name).toBe("Alice")
        expect(parsed.age).toBe(30)
    })

    test("round-trip nested object", () => {
        const obj = { user: { name: "Bob", active: true } }
        const xml = objToXml(obj)
        const parsed = xmlToObj(xml)
        expect(parsed.user.name).toBe("Bob")
        expect(parsed.user.active).toBe(true)
    })

    test("round-trip array", () => {
        const obj = { items: ["a", "b", "c"] }
        const xml = objToXml(obj)
        const parsed = xmlToObj(xml)
        expect(parsed.items).toEqual(["a", "b", "c"])
    })

    test("handles plain text (no XML)", () => {
        expect(xmlToObj("just text")).toBe("just text")
    })

    test("parses agent response format", () => {
        const xml = `<response>
      <message>Creating a file</message>
      <tool_invocations>
        <invocation>
          <tool>write_file</tool>
          <params><path>test.txt</path><content>hello</content></params>
          <reasoning>Need to create the file</reasoning>
        </invocation>
      </tool_invocations>
    </response>`
        const parsed = xmlToObj(xml)
        expect(parsed.response.message).toBe("Creating a file")
        expect(parsed.response.tool_invocations.invocation.tool).toBe("write_file")
        expect(parsed.response.tool_invocations.invocation.params.path).toBe("test.txt")
    })
})

// ── Skills Tests ──

describe("Skills", () => {
    const tmpDir = join(process.cwd(), ".test-skills-tmp")

    test("loads .md skill file", async () => {
        mkdirSync(tmpDir, { recursive: true })
        const mdContent = `---
name: git
description: Git version control
---

## Commands

### commit
Create a commit.
\`\`\`bash
git commit -m "{message}"
\`\`\`
- **message**: Commit message`
        const path = join(tmpDir, "git.md")
        writeFileSync(path, mdContent)

        const loaded = await loadSkills([path])
        expect(loaded).toHaveLength(1)
        expect(loaded[0].name).toBe("git")
        expect(loaded[0].description).toBe("Git version control")
        expect(loaded[0].content).toContain("git commit")

        rmSync(tmpDir, { recursive: true, force: true })
    })

    test("formats skills for prompt", () => {
        const skills = [{
            name: "npm",
            description: "Node package manager",
            content: "### install\nInstall packages.\n```bash\nnpm install {pkg}\n```\n\n### test\nRun tests.\n```bash\nnpm test\n```",
            path: "/tmp/npm.md",
        }]
        const prompt = formatSkillsForPrompt(skills)
        expect(prompt).toContain("npm")
        expect(prompt).toContain("npm install {pkg}")
        expect(prompt).toContain("AVAILABLE SKILLS")
    })

    test("formats empty skills", () => {
        expect(formatSkillsForPrompt([])).toBe("")
    })
})

// ── Tools Tests ──

describe("Tools", () => {
    const tmpDir = join(process.cwd(), ".test-tools-tmp")

    test("creates 6 built-in tools", () => {
        const tools = createBuiltinTools("/tmp", 5000)
        expect(tools.length).toBe(6)
        expect(tools.map(t => t.name)).toEqual(["read_file", "write_file", "edit_file", "exec", "list_dir", "search"])
    })

    test("read_file reads existing file", async () => {
        mkdirSync(tmpDir, { recursive: true })
        writeFileSync(join(tmpDir, "hello.txt"), "world")

        const tools = createBuiltinTools(tmpDir, 5000)
        const readFile = tools.find(t => t.name === "read_file")!
        const result = await readFile.execute({ path: "hello.txt" })
        expect(result.success).toBe(true)
        expect(result.output).toBe("world")

        rmSync(tmpDir, { recursive: true, force: true })
    })

    test("read_file fails on missing file", async () => {
        const tools = createBuiltinTools(".", 5000)
        const readFile = tools.find(t => t.name === "read_file")!
        const result = await readFile.execute({ path: "nonexistent-file-12345.txt" })
        expect(result.success).toBe(false)
        expect(result.error).toContain("not found")
    })

    test("write_file creates and reads back", async () => {
        mkdirSync(tmpDir, { recursive: true })
        const tools = createBuiltinTools(tmpDir, 5000)
        const writeFile = tools.find(t => t.name === "write_file")!
        const readFile = tools.find(t => t.name === "read_file")!

        await writeFile.execute({ path: "new.txt", content: "test content" })
        const result = await readFile.execute({ path: "new.txt" })
        expect(result.success).toBe(true)
        expect(result.output).toBe("test content")

        rmSync(tmpDir, { recursive: true, force: true })
    })

    test("edit_file replaces content", async () => {
        mkdirSync(tmpDir, { recursive: true })
        writeFileSync(join(tmpDir, "edit.txt"), "hello world")

        const tools = createBuiltinTools(tmpDir, 5000)
        const editFile = tools.find(t => t.name === "edit_file")!
        const readFile = tools.find(t => t.name === "read_file")!

        const editResult = await editFile.execute({ path: "edit.txt", target: "hello", replacement: "goodbye" })
        expect(editResult.success).toBe(true)

        const readResult = await readFile.execute({ path: "edit.txt" })
        expect(readResult.output).toBe("goodbye world")

        rmSync(tmpDir, { recursive: true, force: true })
    })

    test("edit_file fails on missing target", async () => {
        mkdirSync(tmpDir, { recursive: true })
        writeFileSync(join(tmpDir, "edit2.txt"), "hello world")

        const tools = createBuiltinTools(tmpDir, 5000)
        const editFile = tools.find(t => t.name === "edit_file")!
        const result = await editFile.execute({ path: "edit2.txt", target: "xyz", replacement: "abc" })
        expect(result.success).toBe(false)
        expect(result.error).toContain("not found")

        rmSync(tmpDir, { recursive: true, force: true })
    })

    test("exec runs command", async () => {
        const tools = createBuiltinTools(".", 5000)
        const exec = tools.find(t => t.name === "exec")!
        const result = await exec.execute({ command: "echo hello" })
        expect(result.success).toBe(true)
        expect(result.output).toContain("hello")
    })

    test("exec reports failed commands", async () => {
        const tools = createBuiltinTools(".", 5000)
        const exec = tools.find(t => t.name === "exec")!
        const result = await exec.execute({ command: "exit 1" })
        expect(result.success).toBe(false)
    })

    test("list_dir lists directory contents", async () => {
        mkdirSync(join(tmpDir, "sub"), { recursive: true })
        writeFileSync(join(tmpDir, "file1.txt"), "hello")
        writeFileSync(join(tmpDir, "sub", "file2.ts"), "world")

        const tools = createBuiltinTools(tmpDir, 5000)
        const listDir = tools.find(t => t.name === "list_dir")!
        const result = await listDir.execute({ path: "." })
        expect(result.success).toBe(true)
        expect(result.output).toContain("file1.txt")
        expect(result.output).toContain("sub/")

        rmSync(tmpDir, { recursive: true, force: true })
    })

    test("list_dir with depth 2 shows nested files", async () => {
        mkdirSync(join(tmpDir, "deep"), { recursive: true })
        writeFileSync(join(tmpDir, "deep", "nested.txt"), "deep content")

        const tools = createBuiltinTools(tmpDir, 5000)
        const listDir = tools.find(t => t.name === "list_dir")!
        const result = await listDir.execute({ path: ".", depth: 2 })
        expect(result.success).toBe(true)
        expect(result.output).toContain("nested.txt")

        rmSync(tmpDir, { recursive: true, force: true })
    })

    test("search finds pattern in files", async () => {
        mkdirSync(tmpDir, { recursive: true })
        writeFileSync(join(tmpDir, "code.ts"), "function greet() {\n  return 'hello'\n}")
        writeFileSync(join(tmpDir, "readme.md"), "# Project\nSome docs about greet function")

        const tools = createBuiltinTools(tmpDir, 5000)
        const search = tools.find(t => t.name === "search")!
        const result = await search.execute({ pattern: "greet", path: "." })
        expect(result.success).toBe(true)
        expect(result.output).toContain("code.ts")
        expect(result.output).toContain("greet")

        rmSync(tmpDir, { recursive: true, force: true })
    })

    test("search with include filter", async () => {
        mkdirSync(tmpDir, { recursive: true })
        writeFileSync(join(tmpDir, "app.ts"), "const x = 'target'")
        writeFileSync(join(tmpDir, "app.css"), ".target { color: red }")

        const tools = createBuiltinTools(tmpDir, 5000)
        const search = tools.find(t => t.name === "search")!
        const result = await search.execute({ pattern: "target", path: ".", include: "*.ts" })
        expect(result.success).toBe(true)
        expect(result.output).toContain("app.ts")
        expect(result.output).not.toContain("app.css")

        rmSync(tmpDir, { recursive: true, force: true })
    })

    test("search returns no matches message", async () => {
        mkdirSync(tmpDir, { recursive: true })
        writeFileSync(join(tmpDir, "empty.txt"), "nothing here")

        const tools = createBuiltinTools(tmpDir, 5000)
        const search = tools.find(t => t.name === "search")!
        const result = await search.execute({ pattern: "xyznonexistent", path: "." })
        expect(result.success).toBe(true)
        expect(result.output).toContain("No matches")

        rmSync(tmpDir, { recursive: true, force: true })
    })
})

// ── Agent Tests ──

describe("Agent", () => {
    test("constructor allows empty objectives for plan()", () => {
        const agent = new Agent({ model: "test" })
        expect(agent).toBeDefined()
    })

    test("run() throws without objectives", async () => {
        const agent = new Agent({ model: "test" })
        const gen = agent.run("hello")
        await expect(gen.next()).rejects.toThrow("No objectives defined")
    })

    test("constructor accepts valid config with objectives", () => {
        const agent = new Agent({
            model: "gemini-3-flash-preview",
            objectives: [{
                name: "test",
                description: "A test objective",
                validate: () => ({ met: true, reason: "always" }),
            }],
        })
        expect(agent).toBeDefined()
    })

    test("constructor accepts skill file paths", () => {
        const agent = new Agent({
            model: "test",
            skills: ["./skills/docker.md"],
            objectives: [{
                name: "done",
                description: "Finish",
                validate: () => ({ met: true, reason: "ok" }),
            }],
        })
        expect(agent).toBeDefined()
    })
})

// ── Objectives Tests ──

describe("Objectives", () => {
    const { hydrateObjective } = require("./objectives")
    const tmpDir = join(process.cwd(), ".test-obj-tmp")

    test("file_exists — met when file exists", async () => {
        mkdirSync(tmpDir, { recursive: true })
        writeFileSync(join(tmpDir, "check.txt"), "hello")

        const obj = hydrateObjective({
            name: "file_check",
            description: "Check file",
            type: "file_exists",
            params: { path: "check.txt" },
        }, tmpDir)

        const result = await obj.validate({
            messages: [], iteration: 0, toolHistory: [], touchedFiles: new Set(),
        })
        expect(result.met).toBe(true)
        rmSync(tmpDir, { recursive: true, force: true })
    })

    test("file_exists — not met when missing", async () => {
        const obj = hydrateObjective({
            name: "missing",
            description: "Missing file",
            type: "file_exists",
            params: { path: "nonexistent-12345.txt" },
        }, ".")

        const result = await obj.validate({
            messages: [], iteration: 0, toolHistory: [], touchedFiles: new Set(),
        })
        expect(result.met).toBe(false)
    })

    test("command_succeeds — met when last exec succeeded", () => {
        const obj = hydrateObjective({
            name: "cmd",
            description: "Command check",
            type: "command_succeeds",
            params: { command: "bun test" },
        }, ".")

        const result = obj.validate({
            messages: [],
            iteration: 0,
            toolHistory: [{
                iteration: 0,
                tool: "exec",
                params: { command: "bun test" },
                result: { success: true, output: "pass" },
            }],
            touchedFiles: new Set(),
        })
        expect(result.met).toBe(true)
    })

    test("command_succeeds — not met when not run", () => {
        const obj = hydrateObjective({
            name: "cmd",
            description: "Command check",
            type: "command_succeeds",
            params: { command: "bun test" },
        }, ".")

        const result = obj.validate({
            messages: [], iteration: 0, toolHistory: [], touchedFiles: new Set(),
        })
        expect(result.met).toBe(false)
    })

    test("command_output_contains — checks output text", () => {
        const obj = hydrateObjective({
            name: "output",
            description: "Output check",
            type: "command_output_contains",
            params: { command: "echo", text: "hello" },
        }, ".")

        const met = obj.validate({
            messages: [],
            iteration: 0,
            toolHistory: [{
                iteration: 0,
                tool: "exec",
                params: { command: "echo hello" },
                result: { success: true, output: "hello world" },
            }],
            touchedFiles: new Set(),
        })
        expect(met.met).toBe(true)

        const notMet = obj.validate({
            messages: [],
            iteration: 0,
            toolHistory: [{
                iteration: 0,
                tool: "exec",
                params: { command: "echo bye" },
                result: { success: true, output: "bye world" },
            }],
            touchedFiles: new Set(),
        })
        expect(notMet.met).toBe(false)
    })
})

// ── Session Tests ──

import { Session } from "./session"

describe("Session", () => {
    test("constructor generates unique id", () => {
        const s1 = new Session({ model: "test" })
        const s2 = new Session({ model: "test" })
        expect(s1.id).toBeTruthy()
        expect(s2.id).toBeTruthy()
        expect(s1.id).not.toBe(s2.id)
    })

    test("requireConfirmation defaults to true", () => {
        const session = new Session({ model: "test" })
        expect(session.requireConfirmation).toBe(true)
    })

    test("requireConfirmation can be disabled", () => {
        const session = new Session({ model: "test", requireConfirmation: false })
        expect(session.requireConfirmation).toBe(false)
    })

    test("history starts empty", () => {
        const session = new Session({ model: "test" })
        expect(session.getHistory()).toEqual([])
    })

    test("objectives start empty", () => {
        const session = new Session({ model: "test" })
        expect(session.getObjectives()).toEqual([])
    })

    test("isAwaitingConfirmation starts false", () => {
        const session = new Session({ model: "test" })
        expect(session.isAwaitingConfirmation).toBe(false)
    })

    test("confirmObjectives is safe to call when not awaiting", () => {
        const session = new Session({ model: "test" })
        // Should not throw
        session.confirmObjectives()
        expect(session.isAwaitingConfirmation).toBe(false)
    })

    test("rejectObjectives is safe to call when not awaiting", () => {
        const session = new Session({ model: "test" })
        // Should not throw
        session.rejectObjectives()
        expect(session.isAwaitingConfirmation).toBe(false)
    })

    test("abort is safe to call when nothing running", () => {
        const session = new Session({ model: "test" })
        // Should not throw
        session.abort()
        expect(session.isAwaitingConfirmation).toBe(false)
    })
})

// ── Tool Call Text Parsing Tests ──

describe("Tool call text parsing", () => {
    // Create an Agent instance to test parseToolCallsFromText (via its private method)
    // We access it through a prototype hack since it's private
    const agent = new Agent({
        model: "test",
        objectives: [{ name: "x", description: "x", validate: () => ({ met: true, reason: "" }) }],
    })
    const parse = (agent as any).parseToolCallsFromText.bind(agent)

    test("parses JSON code fence — single tool", () => {
        const text = `I'll read the file.\n\n\`\`\`json\n[{"tool": "read_file", "params": {"path": "hello.txt"}}]\n\`\`\``
        const result = parse(text)
        expect(result).toHaveLength(1)
        expect(result[0].tool).toBe("read_file")
        expect(result[0].params.path).toBe("hello.txt")
    })

    test("parses JSON code fence — multiple tools", () => {
        const text = `Let me check.\n\n\`\`\`json\n[\n  {"tool": "read_file", "params": {"path": "a.ts"}},\n  {"tool": "exec", "params": {"command": "echo hi"}}\n]\n\`\`\``
        const result = parse(text)
        expect(result).toHaveLength(2)
        expect(result[0].tool).toBe("read_file")
        expect(result[1].tool).toBe("exec")
        expect(result[1].params.command).toBe("echo hi")
    })

    test("parses inline JSON objects", () => {
        const text = `I'll run: {"tool": "exec", "params": {"command": "bun test"}}`
        const result = parse(text)
        expect(result).toHaveLength(1)
        expect(result[0].tool).toBe("exec")
        expect(result[0].params.command).toBe("bun test")
    })

    test("returns empty array for plain text", () => {
        const text = "This is just a regular response with no tool calls."
        const result = parse(text)
        expect(result).toHaveLength(0)
    })

    test("handles malformed JSON gracefully", () => {
        const text = `\`\`\`json\n{bad json here}\n\`\`\``
        const result = parse(text)
        expect(result).toHaveLength(0)
    })
})
